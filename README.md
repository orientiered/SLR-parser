# SLR парсер

LR(0) синтаксический анализатор с построением таблицы с SLR(1)
## Компиляция

**Зависимости**:
1. `Flex`
2. `cmake 3.16+`
3. `dot (graphviz)`

**Инициализация**:
```bash
    git submodule update --init --recursive
```

**Сборка**:
```bash
    cmake -B build
    cmake --build build
    # executable slr.exe

    cmake --build build --target test # Запуск тестов
```


**Использование**:
Запуск без аргументов принимает выражение из стандартного ввода.
При указании файла в аргументах командной строки будет считано выражение из него.

После окончания потока ввода будет либо выведено сообщение об ошибке с указанием предполагаемого места, либо сообщение об успешном разборе.

При успешном разборе в файл `parse_dump.csv` будет записана таблица с действиями анализатора во время разбора, также при помощи `dot` будет сгенерировано AST дерево в файле `ast.svg`.

`--export-table` - экспортировать `action/goto` таблицу в файл

## Описание разбираемого языка

Этот парсер работает с грамматикой языка, состоящего из математических выражений вида

```
(1+x-((t2*t3))/64)+22
```

Т.е. из положительных чисел, индентификаторов из латинских букв, скобок и операций +-*/.

Грамматика языка:
```
E0 -> E # расширение грамматики для окончания разбора
E -> E [+-] T | T
T -> T [*/] F | F
F -> ( E ) | id | num
```

**Тестирование**:

### Построение ACTION/GOTO таблицы

1. Проходимся по всем каноническим состояним
2. Для каждого состояния проходимся по всем пунктам (продукция с точкой):
3. Смотрим на вид пункта:
    + точка в конце правила `S'->S.`

        конец разбора на символ $, принятие

        `ACTION[state_idx][END] = {ACCEPT}`
    + после точки есть НЕТЕРМИНАЛ `a`

        `j =  state_transitions[{state_idx, a}]`

        ставим `ACTION[state_idx][a] = {SHIFT, j}`
    + точка в конце правила `A -> smth .` с номером `k`

        Ставим для всех терминалов `a` из `FOLLOW[A]`
        `ACTION[state_idx][a] = {REDUCE, k}`;

