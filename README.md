# SLR парсер

LR(0) синтаксический анализатор с построением таблицы с SLR(1)
## Компиляция

**Зависимости**:
1. `Flex`
2. `cmake 3.16+`
3. `dot (graphviz)`

**Инициализация**:
```bash
    git submodule update --init --recursive
```

**Сборка**:
```bash
    cmake -B build
    cmake --build build
    # executable slr.exe

    cmake --build build --target test # Запуск тестов
```


**Использование**:
Запуск без аргументов принимает выражение из стандартного ввода.
При указании файла в аргументах командной строки (c флагом `-f`) будет считано выражение из него.

После окончания потока ввода будет либо выведено сообщение об ошибке с указанием предполагаемого места, либо сообщение об успешном разборе.

При успешном разборе в файл `parse_log.csv` будет записана таблица с действиями анализатора во время разбора, также при помощи `dot` будет сгенерировано AST дерево в файле `ast.svg`.

`--export-table` - экспортировать `action/goto` таблицу в файл

## Описание разбираемого языка

Этот парсер работает с грамматикой языка, состоящего из математических выражений вида

```
(1+x-((t2*t3))/64)+22
```

Т.е. из положительных чисел, индентификаторов из латинских букв, скобок и операций +-*/.

Грамматика языка:
```
E0 -> E # расширение грамматики для окончания разбора
E -> E [+-] T | T
T -> T [*/] F | F
F -> ( E ) | id | num
```

### Пример таблицы разбора

| State |  Stack            | Input  |  Action        |
| -- | -------------------- | ------ | -------------- |
|  0 |  $                   |  1     |  S4            |
|  4 |  $ num               |  +     |  R9 F -> num   |
|  3 |  $ F                 |  +     |  R4 T -> F     |
|  2 |  $ T                 |  +     |  R1 E -> T     |
|  1 |  $ E                 |  +     |  S7            |
|  7 |  $ E +               |  5     |  S4            |
|  4 |  $ E + num           |  *     |  R9 F -> num   |
|  3 |  $ E + F             |  *     |  R4 T -> F     |
| 12 |  $ E + T             |  *     |  S9            |
|  9 |  $ E + T *           |  v     |  S5            |
|  5 |  $ E + T * id        |  -     |  R8 F -> id    |
| 14 |  $ E + T * F         |  -     |  R5 T -> T * F |
| 12 |  $ E + T             |  -     |  R2 E -> E + T |
|  1 |  $ E                 |  -     |  S8            |
|  8 |  $ E -               |  fgh   |  S5            |
|  5 |  $ E - id            |  /     |  R8 F -> id    |
|  3 |  $ E - F             |  /     |  R4 T -> F     |
| 13 |  $ E - T             |  /     |  S10           |
| 10 |  $ E - T /           |  (     |  S6            |
|  6 |  $ E - T / (         |  44444 |  S4            |
|  4 |  $ E - T / ( num     |  -     |  R9 F -> num   |
|  3 |  $ E - T / ( F       |  -     |  R4 T -> F     |
|  2 |  $ E - T / ( T       |  -     |  R1 E -> T     |
| 11 |  $ E - T / ( E       |  -     |  S8            |
|  8 |  $ E - T / ( E -     |  24    |  S4            |
|  4 |  $ E - T / ( E - num |  )     |  R9 F -> num   |
|  3 |  $ E - T / ( E - F   |  )     |  R4 T -> F     |
| 13 |  $ E - T / ( E - T   |  )     |  R3 E -> E - T |
| 11 |  $ E - T / ( E       |  )     |  S16           |
| 16 |  $ E - T / ( E )     |        |  R7 F -> ( E ) |
| 15 |  $ E - T / F         |        |  R6 T -> T / F |
| 13 |  $ E - T             |        |  R3 E -> E - T |
|  1 |  $ E                 |        |  A0            |


### Построение ACTION/GOTO таблицы

1. Проходимся по всем каноническим состояним
2. Для каждого состояния проходимся по всем пунктам (продукция с точкой):
3. Смотрим на вид пункта:
    + точка в конце правила `S'->S.`

        конец разбора на символ $, принятие

        `ACTION[state_idx][END] = {ACCEPT}`
    + после точки есть НЕТЕРМИНАЛ `a`

        `j =  state_transitions[{state_idx, a}]`

        ставим `ACTION[state_idx][a] = {SHIFT, j}`
    + точка в конце правила `A -> smth .` с номером `k`

        Ставим для всех терминалов `a` из `FOLLOW[A]`
        `ACTION[state_idx][a] = {REDUCE, k}`;

Таблица GOTO строится для нетерминалов по переходам, которые были получены во время построения канонических состояний:

Если `GOTO(state_i, symbol) == state_j`, то `state_transitions[{i,symbol}] = j`

```
for start_state, symbol, end_state : state_transitions {
    GOTO[start_state][symbol] = end_state;
}
```

